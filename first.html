<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ é©¬å¹´å¤§å‰ - ç‚«é…·çƒŸèŠ±ç§€</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            touch-action: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 3D è§†å·®èƒŒæ™¯å±‚ */
        .bg-layers {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .bg-layer {
            position: absolute;
            width: 120%;
            height: 120%;
            top: -10%;
            left: -10%;
            opacity: 0.3;
            background: radial-gradient(circle at 50% 50%, 
                rgba(255, 215, 0, 0.3) 0%, 
                rgba(255, 69, 0, 0.2) 30%, 
                rgba(138, 43, 226, 0.2) 60%, 
                transparent 100%);
            animation: rotate 20s linear infinite;
        }

        .bg-layer:nth-child(2) {
            animation-duration: 30s;
            animation-direction: reverse;
            background: radial-gradient(circle at 30% 70%, 
                rgba(255, 0, 128, 0.2) 0%, 
                transparent 50%);
        }

        .bg-layer:nth-child(3) {
            animation-duration: 25s;
            background: radial-gradient(circle at 70% 30%, 
                rgba(0, 255, 255, 0.2) 0%, 
                transparent 50%);
        }

        @keyframes rotate {
            from { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            to { transform: rotate(360deg) scale(1); }
        }

        /* ä¸»å®¹å™¨ */
        .container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            pointer-events: none;
            width: 90%;
            max-width: 600px;
        }

        /* é‡‘é©¬åŠ¨ç”» */
        .horse-container {
            position: relative;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        .golden-horse {
            font-size: 6rem;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)) 
                    drop-shadow(0 0 40px rgba(255, 140, 0, 0.6));
            animation: gallop 0.8s ease-in-out infinite, glow 2s ease-in-out infinite alternate;
            display: inline-block;
        }

        @keyframes gallop {
            0%, 100% { transform: rotate(-5deg) scale(1) translateY(0px); }
            25% { transform: rotate(5deg) scale(1.05) translateY(-10px); }
            50% { transform: rotate(-3deg) scale(1) translateY(0px); }
            75% { transform: rotate(3deg) scale(1.05) translateY(-5px); }
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 40px rgba(255, 140, 0, 0.6)); }
            to { filter: drop-shadow(0 0 30px rgba(255, 215, 0, 1)) drop-shadow(0 0 60px rgba(255, 69, 0, 0.8)); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
        }

        /* æ ‡é¢˜ç‰¹æ•ˆ */
        h1 {
            font-size: 3.5rem;
            font-weight: 900;
            margin: 20px 0;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700, #ff8c00, #ffd700);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shine 3s ease-in-out infinite, shake 5s ease-in-out infinite;
            text-shadow: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            letter-spacing: 0.1em;
        }

        @keyframes shine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes shake {
            0%, 90%, 100% { transform: translateX(0); }
            92% { transform: translateX(-2px) rotate(-1deg); }
            94% { transform: translateX(2px) rotate(1deg); }
            96% { transform: translateX(-1px); }
            98% { transform: translateX(1px); }
        }

        /* ç¥ç¦è¯­å¡ç‰‡ */
        .blessing-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 8px 32px 0 rgba(255, 140, 0, 0.2);
            animation: cardFloat 4s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .blessing-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff0000, #ffd700, #ff0000, #ffd700);
            border-radius: 20px;
            opacity: 0.5;
            z-index: -1;
            animation: borderRotate 3s linear infinite;
        }

        @keyframes borderRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes cardFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(1deg); }
        }

        .blessing-text {
            font-size: 1.3rem;
            line-height: 2;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .blessing-text span {
            display: block;
            margin: 10px 0;
            opacity: 0;
            animation: textAppear 0.5s ease-out forwards;
        }

        .blessing-text span:nth-child(1) { animation-delay: 0.1s; }
        .blessing-text span:nth-child(2) { animation-delay: 0.3s; }
        .blessing-text span:nth-child(3) { animation-delay: 0.5s; }
        .blessing-text span:nth-child(4) { animation-delay: 0.7s; }

        @keyframes textAppear {
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        /* æç¤ºæ–‡å­— */
        .hint {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 1rem;
            z-index: 20;
            animation: pulse 2s infinite;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
        }

        /* ç‚¹å‡»ç‰¹æ•ˆæ–‡å­— */
        .click-effect {
            position: absolute;
            color: #ffd700;
            font-size: 1.5rem;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 100;
            text-shadow: 0 0 10px rgba(255,215,0,0.8);
        }

        @keyframes floatUp {
            0% { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
            100% { 
                opacity: 0; 
                transform: translateY(-100px) scale(1.5); 
            }
        }

        /* çº¢åŒ…é›¨ */
        .red-packet {
            position: fixed;
            font-size: 2rem;
            z-index: 5;
            pointer-events: none;
            animation: fall linear;
        }

        @keyframes fall {
            to { transform: translateY(100vh) rotate(360deg); }
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; }
            .golden-horse { font-size: 4rem; }
            .blessing-text { font-size: 1.1rem; }
            .blessing-card { padding: 20px; }
        }
    </style>
</head>
<body>
    <!-- 3D èƒŒæ™¯å±‚ -->
    <div class="bg-layers">
        <div class="bg-layer"></div>
        <div class="bg-layer"></div>
        <div class="bg-layer"></div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="container">
        <div class="horse-container">
            <div class="golden-horse">ğŸ</div>
        </div>
        
        <h1>é©¬å¹´å¤§å‰</h1>
        
        <div class="blessing-card">
            <div class="blessing-text">
                <span>ğŸ‡ é©¬åˆ°æˆåŠŸï¼Œå‰ç¨‹ä¼¼é”¦</span>
                <span>ğŸ´ ä¸€é©¬å½“å…ˆï¼Œä¸‡äº‹å¦‚æ„</span>
                <span>âœ¨ é¾™é©¬ç²¾ç¥ï¼Œé˜–å®¶æ¬¢ä¹</span>
                <span>ğŸ§§ é©¬ä¸Šæœ‰é’±ï¼Œç¦æ°”æ»¡æ»¡</span>
            </div>
        </div>
    </div>

    <div class="hint">ğŸ‘† ç‚¹å‡»å±å¹•æ”¾çƒŸèŠ± | é•¿æŒ‰è“„åŠ› ğŸ‘†</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // é«˜æ¸…å±é€‚é…
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resize();
        window.addEventListener('resize', resize);

        // å·¥å…·å‡½æ•°
        const random = (min, max) => Math.random() * (max - min) + min;
        const randomColor = () => {
            const colors = [
                '#ff0000', '#ffd700', '#ff69b4', '#00ff00', 
                '#00ffff', '#ff4500', '#ffff00', '#ff1493',
                '#ff6347', '#ffa500', '#9370db', '#00fa9a'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        };

        // ç²’å­ç³»ç»Ÿï¼ˆå¸¦ç‰©ç†ï¼‰
        class Particle {
            constructor(x, y, color, velocity, size, decay) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity || { x: random(-3, 3), y: random(-3, 3) };
                this.size = size || random(2, 5);
                this.decay = decay || random(0.01, 0.02);
                this.alpha = 1;
                this.gravity = 0.1;
                this.friction = 0.98;
                this.trail = [];
                this.trailLength = 5;
            }

            update() {
                // ä¿å­˜è½¨è¿¹
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) {
                    this.trail.shift();
                }

                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= this.decay;
            }

            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                ctx.save();
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const trailAlpha = (i / this.trail.length) * this.alpha * 0.5;
                    ctx.globalAlpha = trailAlpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.size * (i / this.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                // ç»˜åˆ¶ä¸»ä½“
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ç«ç®­å‡ç©ºé˜¶æ®µ
        class Rocket {
            constructor(x, y, targetY, color) {
                this.x = x;
                this.y = y;
                this.targetY = targetY;
                this.color = color;
                this.velocity = { x: random(-1, 1), y: random(-12, -8) };
                this.trail = [];
                this.explode = false;
                this.dead = false;
            }

            update() {
                this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                if (this.trail.length > 10) this.trail.shift();

                this.trail.forEach(t => t.alpha -= 0.1);
                this.trail = this.trail.filter(t => t.alpha > 0);

                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.velocity.y += 0.2; // é‡åŠ›å‡é€Ÿ

                if (this.velocity.y >= 0 || this.y <= this.targetY) {
                    this.explode = true;
                    this.dead = true;
                }
            }

            draw() {
                // å°¾ç„°
                this.trail.forEach(t => {
                    ctx.save();
                    ctx.globalAlpha = t.alpha * 0.5;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                // å¼¹å¤´
                ctx.save();
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // çƒŸèŠ±çˆ†ç‚¸
        class Firework {
            constructor(x, y, type = 'random') {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.type = type === 'random' ? ['circle', 'heart', 'star', 'random'][Math.floor(Math.random() * 4)] : type;
                this.init();
            }

            init() {
                const particleCount = this.type === 'heart' ? 50 : 80;
                
                for (let i = 0; i < particleCount; i++) {
                    let velocity;
                    
                    switch(this.type) {
                        case 'circle':
                            const angle = (Math.PI * 2 / particleCount) * i;
                            const speed = random(2, 6);
                            velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                            break;
                            
                        case 'heart':
                            // å¿ƒå½¢å…¬å¼
                            const t = (Math.PI * 2 / particleCount) * i;
                            const scale = random(0.5, 1.5);
                            velocity = { 
                                x: (16 * Math.pow(Math.sin(t), 3)) * 0.1 * scale + random(-1, 1), 
                                y: -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.1 * scale + random(-1, 1)
                            };
                            break;
                            
                        case 'star':
                            const starAngle = (Math.PI * 2 / particleCount) * i;
                            const r = i % 2 === 0 ? 6 : 3; // æ˜Ÿå½¢åŠå¾„å˜åŒ–
                            velocity = { x: Math.cos(starAngle) * r, y: Math.sin(starAngle) * r };
                            break;
                            
                        default:
                            velocity = { x: random(-6, 6), y: random(-6, 6) };
                    }
                    
                    this.particles.push(new Particle(this.x, this.y, randomColor(), velocity));
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.update();
                    return p.alpha > 0;
                });
            }

            draw() {
                this.particles.forEach(p => p.draw());
            }

            isDead() {
                return this.particles.length === 0;
            }
        }

        // ç®¡ç†å™¨
        const rockets = [];
        const fireworks = [];
        let autoFireInterval;

        // è‡ªåŠ¨æ”¾çƒŸèŠ±
        function autoFire() {
            const x = random(width * 0.2, width * 0.8);
            const y = random(height * 0.2, height * 0.5);
            const color = randomColor();
            rockets.push(new Rocket(x, height, y, color));
        }

        // æ‰‹åŠ¨è§¦å‘ï¼ˆæ›´çŒ›çƒˆï¼‰
        function manualFire(x, y, power = 1) {
            const colors = [randomColor(), randomColor(), randomColor()];
            
            // ä¸»çƒŸèŠ±
            fireworks.push(new Firework(x, y, 'circle'));
            
            // å¦‚æœé•¿æŒ‰è“„åŠ›ï¼Œæ”¾æ›´å¤š
            if (power > 1) {
                setTimeout(() => fireworks.push(new Firework(x + random(-50, 50), y + random(-50, 50), 'heart')), 100);
                setTimeout(() => fireworks.push(new Firework(x + random(-50, 50), y + random(-50, 50), 'star')), 200);
            } else {
                // æ™®é€šç‚¹å‡»å‘¨è¾¹å°çƒŸèŠ±
                setTimeout(() => fireworks.push(new Firework(x + random(-30, 30), y + random(-30, 30))), 50);
            }
        }

        // ç‚¹å‡»æ–‡å­—æ•ˆæœ
        function showClickText(x, y) {
            const texts = ['ğŸ', 'ğŸ’°', 'âœ¨', 'ğŸ§§', 'é©¬åˆ°æˆåŠŸ', 'å¤§å‰å¤§åˆ©'];
            const text = texts[Math.floor(Math.random() * texts.length)];
            const div = document.createElement('div');
            div.className = 'click-effect';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        // çº¢åŒ…é›¨
        function createRedPacket() {
            const packet = document.createElement('div');
            packet.className = 'red-packet';
            packet.textContent = 'ğŸ§§';
            packet.style.left = random(0, width) + 'px';
            packet.style.top = '-50px';
            packet.style.animationDuration = random(3, 6) + 's';
            document.body.appendChild(packet);
            
            setTimeout(() => packet.remove(), 6000);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            // æ‹–å°¾æ•ˆæœï¼ˆåŠé€æ˜è¦†ç›–ï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // æ›´æ–°ç«ç®­
            for (let i = rockets.length - 1; i >= 0; i--) {
                const r = rockets[i];
                r.update();
                r.draw();
                
                if (r.explode) {
                    fireworks.push(new Firework(r.x, r.y));
                    rockets.splice(i, 1);
                } else if (r.dead) {
                    rockets.splice(i, 1);
                }
            }

            // æ›´æ–°çƒŸèŠ±
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const f = fireworks[i];
                f.update();
                f.draw();
                if (f.isDead()) {
                    fireworks.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        // äº‹ä»¶ç›‘å¬
        let longPressTimer;
        let isLongPress = false;

        function handleStart(e) {
            isLongPress = false;
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX;
            const y = touch.clientY;
            
            longPressTimer = setTimeout(() => {
                isLongPress = true;
                manualFire(x, y, 2); // è“„åŠ›å¤§æ‹›
                showClickText(x, y);
            }, 500);
        }

        function handleEnd(e) {
            clearTimeout(longPressTimer);
            if (!isLongPress) {
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const x = touch.clientX;
                const y = touch.clientY;
                manualFire(x, y, 1); // æ™®é€šç‚¹å‡»
                showClickText(x, y);
            }
        }

        function handleMove(e) {
            // æ»‘åŠ¨æ—¶ä¹Ÿäº§ç”Ÿå°æ˜Ÿæ˜Ÿ
            if (Math.random() > 0.7) {
                const touch = e.touches ? e.touches[0] : e;
                fireworks.push(new Firework(touch.clientX, touch.clientY, 'random'));
            }
        }

        // ç»‘å®šäº‹ä»¶
        document.addEventListener('mousedown', handleStart);
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchstart', handleStart, {passive: false});
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchmove', handleMove, {passive: false});
        document.addEventListener('mousemove', handleMove);

        // å¯åŠ¨
        animate();
        
        // è‡ªåŠ¨æ”¾çƒŸèŠ±ï¼ˆé—´éš”ï¼‰
        autoFireInterval = setInterval(autoFire, 2000);
        
        // éšæœºçº¢åŒ…é›¨
        setInterval(createRedPacket, 1500);
        
        // å¼€åœºç‰¹æ•ˆ
        setTimeout(() => manualFire(width/2, height/3, 3), 500);
        setTimeout(() => manualFire(width/3, height/2, 2), 800);
        setTimeout(() => manualFire(width*2/3, height/2, 2), 1100);
    </script>
</body>
</html>
